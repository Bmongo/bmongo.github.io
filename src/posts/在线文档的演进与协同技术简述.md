---
id: online-docs-evolution
title: 在线文档的演进与协同技术简述
date: 2025/9/13
tags:
  - 在线文档
---

## 1. 发展历程

### 1.1 产品

#### 1.1.1 本地编辑与单机办公

- WPS：求伯君于 1988 年独立开发中国首款文字处理软件，解决当时 DOS 系统无法打印中文的痛点，一度风靡国内市场，但因 1990 年代与 Office 格式互通导致用户流失，直至 2018 年后借移动端（WPS 移动版）重返战场
- Microsoft Office：首个主流文字处理软件，结合 Word、Excel、PowerPoint 形成 Office 套件，通过封闭文档格式（.doc/.xls）压制竞争对手，迫使早期 WPS 兼容其格式而丧失独立性

#### 1.1.2 云端存储与个人笔记

- Google Docs：2006 年 Google 划时代的实现浏览器内多用户实时协作，采用操作转换（OT）算法解决编辑冲突，奠定在线文档技术标准
- 印象笔记：2012 年，EverNote 进入中国，发布中国产品“印象笔记”，得到了用户的认可和好评
- 有道云笔记：2011 年，网易推出的个人笔记软件，但是在当时个人笔记类市场并没有理想的增速发展
- 石墨文档：2015 年发布的中国首个支持多人实时编辑的在线文档，但是早期面临数据丢失、服务器稳定性等问题，为行业积累关键技术经验
- 腾讯文档：2018 年发布，依托微信社交链，2 个月获 2000 万用户，主打轻量化协作
- 金山文档：2018 年发布，基于 WPS 云存储实现的在线文档，兼容本地与在线双模式，通过“本地编辑 + 云端同步”混合架构，解决离线场景痛点

#### 1.1.3 智能在线协作文档

- Notion：2016 年发布提出“all in one“，集成了笔记、知识库、数据表格、看板、日历等多种能力于一体的应用程序
- 语雀：2018 年左右成熟并广泛使用，定位为专业的云端知识库与文档协作工具
- WoLai：2020 年发布，深度对标 Notion，优化中文体验，2023 年被钉钉收购
- 钉钉文档：深度集成于钉钉平台，强调工作场景闭环与组织化管理
- 飞书文档：深度集成于飞书平台，定位为专业的云端知识库与文档协作工具，特别擅长结构化知识管理（空间、知识库、文档树结构）

### 1.2. 技术

观察上述文档产品，大部分产品都是以 Web 页面形式存在，那么我们可能会好奇，其中关键的技术是什么？在线文档产品的技术核心主要在于两点：富文本编辑技术、协同编辑技术

#### 1.2.1. 富文本编辑技术

- 阶段一：通过浏览器原生 API 实现富文内容的修改，输出内容是 HTML 字符串
  - CKEditor（2009 年）
  - UEditor（2012 年）
  - WangEditor（2014 年）
- 阶段二：使用浏览器原生 API 的同时抽象 DSL 去描述内容、操作，通过模型的 API 去修改编辑器中的内容
  - Quill（2012 年）：Delta 模型数据去存储操作序列，由 Delta 数据驱动 UI 的变化，存储最终内容需要回放所有操作。石墨文档基于该编辑器实现
  - ProseMirror（2015 年）：视图层完全基于状态驱动，彻底使用纯 JSON 数据描述富文本内容，支持虚拟 DOM 比对，仅更新差异部分，性能优化更精细，还有插件机制、分层、Schemas（范式）等，但是学习成本高
  - Tiptap：一个现代化的富文本编辑器，基于 ProseMirror 构建，提供了强大的扩展性和可定制性。它广泛应用于构建博客、文档、笔记应用以及任何需要文本编辑的项目

#### 1.2.2. 协同编辑技术

- OT 算法（目前，许多具备协同编辑功能的产品大多基于 OT 进行开发，例如飞书文档、语雀、钉钉文档、石墨文档等）
  - 1989 年，OT 算法正式提出，标志着协同编辑技术的起步
  - 2006 年，Google 首次将 OT 成功运用于商业产品 Google Docs
  - 2011 年，微软在 Office 365 中基于 OT 实现了协同编辑
  - 2012 年，Quill 编辑器开源，其数据模型 Delta 基于 OT 算法设计，降低了协同编辑门槛，随后被更多中小公司产品采用
- CRDT 算法（去中心化，性能得到很大的提升）
  - 2011 同年，CRDT 算法提出，代表了一种新的协同编辑方案的出现
  - 2015 年，Yjs 开源，成为首个成熟的 CRDT 实现库
  - 2017 年：Automerge 开源，专注于 JSON 文档的 CRDT 同步，支持离线编辑和本地优先计算
  - Figma、Miro 等工具采用 CRDT，利用其无需中心服务器的特性支持大规模实时协作
  - [CRDT 相关的实现库](https://crdt.tech/implementations)

## 2. 技术方案

### 2.1. 富文本编辑

富文本编辑器开发的核心在于支持多样化的操作和功能，比如：

- 文本格式化：加粗、斜体、下划线、背景色、字体色等
- 多媒体插入：图片、视频、文件
- 撤销重做：用户在编辑过程中可以随时撤销和重做

#### 2.1.1. contenteditable

以上功能的基础是使用 `contenteditable` 属性，在元素上设置该属性可以使元素允许被用户编辑：

```html
<div contenteditable="true">
  <p>这是一段可编辑的内容</p>
</div>
```

#### 2.1.2. execCommand

`document.execCommand` 是浏览器的一个 API，用于在 HTML 文档中执行与文档相关的命令，该方法最初设计也是给富文本编辑使用的，可以让开发者轻松的实现加粗、斜体、复制、剪切、粘贴等功能。尽管这种方法在过去非常流行，但随着 Web 技术的发展，它的使用逐渐减少，并在一些现代浏览器中被标记为过时或即将废弃

```jsx
// 为选中内容添加加粗样式
document.execCommand("bold");
// 为选中内容添加斜体样式
document.execCommand("italic");
// 为选中内容添加下划线
document.execCommand("underline");
```

> **重要提示**：尽管 `document.execCommand`自前在许多浏览器中仍然可用，但建议开发者尽量避免在新项目中使用它，并逐步迁移到更现代、更可靠的替代方案（使用 Selection 和 Range 代替）

#### 2.1.3. Range 和 Selection

`Range` 和`Selection`是 WebAPI 中的两个重要接口，它们用于处理用户在网页中的文本或元素选择。这两个接口提供了对文档中选定内容的精确控制，可以用来创建富文本编辑器、处理用户选择、实现自定义的文本操作等。（使用场景：划词翻译，网页批注）

##### Range

`Range` 接口表示一个包含节点与文本节点的一部分的文档片段

只读属性：

- `collapsed` 返回表示 Range 的开始和结束节点是否重合的布尔标志
- `commonAncestorContainer` 返回目标节点的共有祖先节点
- `endContainer` 返回 Range 结束所在的 Node
- `endOffset` 返回一个数字，表示 `endContainer` 在 `Range` 中的结束位置
- `startContainer` 返回 Range 开始所在的 Node
- `startOffset`返回一个数字，表示 `Range` 在 `startContainer` 中的起始位置

方法：

- `setStart(node，offset)`设置 Range 的起点为指定节点的特定偏移量
- `setEnd(node，offset)`设置 Range 的终点为指定节点的特定偏移量
- `selectNode(node)`将 Range 设置为包含整个指定节点
- `selectNodeContents(node)`将 Range 设置为包含指定节点的所有内容
- `collapse(toStart)`将 Range 折叠到起点或终点。toStart 为 true 时折叠到起点，反之折叠到终总
- `cloneRange()`创建并返回一个与当前 Range 完全相同的副本
- `deleteContents()`删除 Range 包含的文档内容
- `extractContents()`删除 Range 的内容并返回一个 DocumentFragment，其中包含了被删除的内容
- `insertNode(node)`将一个节点插入到 Range 的起点位置
- `surroundContents(newParent)`将 Range 的内容放入到一个新创建的父节点 newParent 中

```html
<p id="p">
  这是一段内容，<i>我是斜体文字</i>，<strong>我是粗体文字</strong>，我是剩下的内容
</p>

0：这是一段内容，1：<i>我是斜体文字</i> 2：， 3：<strong>我是粗体文字</strong>
4：，我是剩下的内容
```

##### Selection

`Selection` 对象表示用户或脚本在文档中选中的文本范围。它通常与光标或鼠标选择操作相关联。

只读属性：

- `anchorNode` 返回选区开始位置所属的节点
- `anchorOffset` 返回选区的锚节点起点偏移量的数字
- `focusNode` 返回所选内容的结束位置部分所属的节点
- `focusOffset` 返回选区终点（鼠标松开瞬间所记录的那个点）在焦点（Selection.focusNode）中的偏移量
- `isCollapsed` 如果选区的起始点和结束点在同一位置，则返回`true`，否则返回`false`
- `rangeCount` 是一个返回选区中范围数量

方法：

- `getRangeAt(index)`返回选区中的指定 Range 对象。通常使用 getRangeAt(0) 来获取当前选区
- `addRange(range)`向选区添加一个 Range 对象，如果当前已经存在选区，新的范围会与之合并
- `removeAllRanges()`移除所有选区
- `collapse(node,offset)`将选区折叠到文档中的一个特定点即将选区的起点和终点设置为相同的值
- `extend(node,offset)`将当前选区的终点扩展到指定的节点和偏移量
- `collapseToStart()`将选区折叠到起始点
- `collapseToEnd()`将选区折叠到结束点

##### 示例

- 获取当前选中的文本内

```jsx
const selection = document.getSelection();
if (selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  console.log(range.toString());
}
```

- 自动选中内容（[在线 CodePen 链接](https://codepen.io/sl-s-the-looper/pen/ByoVdqo)）

```jsx
const selection = window.getSelection();
const range = document.createRange();
range.setStart(p, 1);
range.setEnd(p, 4);
selection.addRange(range);
```

- 加粗选中内容（[在线 CodePen 链接](https://codepen.io/sl-s-the-looper/pen/wBKXqXK)）

```jsx
const selection = window.getSelection();
if (selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  const strongDom = document.createElement("strong");
  // 删除原有 range 内容，同时将原有 range 内容插入到 strong dom 中
  strongDom.append(range.extractContents());
  range.insertNode(strongDom);
}
```

#### 2.1.4. 结构化 DSL

传统的 HTML 字符串存储方式在扩展性和性能方面存在明显短板。尤其在协同文档场景下，基于 HTML 字符串进行差异对比、变更处理和合并操作逻辑复杂，实现难度大

随着技术的发展，现代编辑器如 Quill、ProseMirror 等逐步采用了一种更先进的方案：它们自定义了一套完整的结构化文档数据模型，完全独立于 HTML。该模型通过 Schema 严格定义文档中允许存在的节点类型、各节点的属性以及节点间的嵌套关系，从而为复杂编辑场景提供了坚实基础

ProseMirror Schema 结构

```json
{
  "type": "doc",
  "content": [
    {
      "type": "heading",
      "attrs": {
        "level": 3
      },
      "content": [
        {
          "type": "text",
          "text": "我是标题 "
        }
      ]
    },
    {
      "type": "paragraph",
      "content": [
        {
          "type": "text",
          "text": "我是正文，"
        },
        {
          "type": "text",
          "marks": [
            {
              "type": "strong"
            }
          ],
          "text": "我是加粗的"
        },
        {
          "type": "text",
          "text": "，"
        },
        {
          "type": "text",
          "marks": [
            {
              "type": "em"
            }
          ],
          "text": "我是斜体的"
        }
      ]
    }
  ]
}
```

### 2.2. 协同编辑方案

协同算法通常用于解决多人实时编辑中可能产生的冲突问题，使得各方的修改可以一致地合并。这在文档编辑、代码协作等场景中尤为重要。两种主要的协同算法是操作变换 (Operational Transformation, OT) 和无冲突复制数据类型 (Conflict-free Replicated Data Type, CRDT)

#### 2.2.1. OT 算法

OT 是一种通过操作转化来解决冲突的算法。它会根据其他用户的并发操作来调整本地操作，从而确保所有用户的编辑结果一致

##### 核心概念

- 操作：用户对文档的原子修改（如插入、删除）
- 转换函数：当两个操作并发时（基于同一文档版本），通过函数 `T(O₁, O₂)`生成新操作 `O₁'`和 `O₂'`，使它们可按不同顺序应用且结果一致
- 因果一致性：操作需按用户实际看到的顺序执行，避免逻辑混乱

##### 冲突解决示例

1. 初始状态：文档内容为："123"
2. 用户操作
   1. 用户 A：`Insert(2, "A")` → 用户 A 本地变为"12A3"
   2. 用户 B：`Insert(3, "B")` → 用户 B 本地变为"123B"
3. OT 转换
   1. 用户 A 收到用户 B 的操作：`T(Insert(2, "A"), Insert(3, "B"))` → `Insert(4, "B")`
   2. 用户 B 收到用户 A 的操作：`T(Insert(3, "B"), Insert(2, "A"))` → `Insert(2, "A")`
4. 用户 A 和用户 B 都得到了一样的结果："12A3B"

##### Transform

OT 算法中最核心的机制就是 transform，用于解决多人协同间的冲突问题。transform 的转换可能会遇到以下情况：

![流程图](https://origin.picgo.net/2025/09/13/1a853a8df0c825e9cf7ced7784b38d46597b10840b533877.png)

##### 服务端

通常作为权威机构，接收所有客户端的操作，负责进行转换、维护文档的最新状态和版本历史，并将转换后的操作广播给所有客户端

> [OT 算法在线演示](https://operational-transformation.github.io/)

#### 2.2.2. CRDT

它是一种特殊的数据结构，被设计用于在分布式系统中的多个副本（节点）之间进行同步。它的核心特点是：无论这些副本以何种顺序收到更新操作，它们最终都能自动地、无需协调地收敛到同一个一致的状态，即满足**交换律、结合律和幂等律**

##### 基于状态 CRDT

基于状态的 CRDT 需要将本地完整的状态发送给其他副本，在这些副本中必须通过可交换、可结合且是幂等的函数进行合并。由于基于状态的 CRDT 需要将整个状态都需要传输给其他副本，所以开销可能会很大

- Grow-only Counter

每个节点维护自己计数器的增量，合并时将所有节点的增量相加

```tsx
class GCounter {
  private id: string;
  private counts: Map<string, number> = new Map();

  constructor(id: string) {
    this.id = id;
  }

  increment(amount = 1) {
    const current = this.counts.get(this.id) || 0;
    this.counts.set(this.id, current + amount);
  }

  get value(): number {
    return Array.from(this.counts.values()).reduce((sum, val) => sum + val, 0);
  }

  merge(other: GCounter) {
    for (const [id, count] of other.counts) {
      const current = this.counts.get(id) || 0;
      if (count > current) {
        this.counts.set(id, count);
      }
    }
  }
}

const counter1 = new GCounter("counter1");
const counter2 = new GCounter("counter2");

counter1.increment(1);
counter2.increment(3);

counter1.merge(counter2);
counter2.merge(counter1);

// 4 4
console.log(counter1.value, counter2.value);
```

- PN-Counter

通过将两个 `GCounter` 组合在一起，创建一个同时支持递增和递减操作的数据类型

```tsx
class PNCounter {
  private id: string;
  private increments: GCounter;
  private decrements: GCounter;
  constructor(id: string) {
    this.id = id;
    this.increments = new GCounter(this.id);
    this.decrements = new GCounter(this.id);
  }

  increment(amount = 1) {
    this.increments.increment(amount);
  }

  decrement(amount = 1) {
    this.decrements.increment(amount);
  }

  get value(): number {
    return this.increments.value - this.decrements.value;
  }

  merge(other: PNCounter) {
    this.increments.merge(other.increments);
    this.decrements.merge(other.decrements);
  }
}

const counter1 = new PNCounter("count1");
const counter2 = new PNCounter("count2");

counter1.increment(1);
counter1.increment(2);
counter1.increment(3);
counter1.decrement(4);

counter2.increment(4);
counter2.increment(3);
counter2.increment(2);
counter2.decrement(1);

counter1.merge(counter2);
counter2.merge(counter1);

// 10 10
console.log(counter1.value, counter2.value);
```

##### 基于操作 CRDT

基于操作 CRDT 只通过传输更新操作来传播状态。例如传输文档编辑中的插入、删除操作，而不需要传输整个文档内容，其他副本接收更新并在本地应用这些更新，基于操作的 CRDT 实现库有 automerge、yjs

###### Yjs 介绍

Yjs 是一个用于构建**协同应用程序**的高性能 **CRDT** (Conflict-Free Replicated Data Type) 库。简单来说，它的核心价值是：

- 解决冲突：当多个用户同时编辑同一份文档（如文本、表格、图形）时，无需复杂的锁机制或中央仲裁，它就能自动地、无冲突地合并所有更改
- 离线优先：即使网络中断，用户依然可以本地编辑。一旦网络恢复，更改会自动同步，最终所有客户端的状态保持一致
- 高性能：算法经过高度优化，非常节省内存和网络资源

通过以下技术方案实现以上价值：

- 保证一致性：所有客户端都收到了相同的操作集，无论这些操作的接收顺序如何，最终它们呈现出的文档状态都是一致的
- 基于向量时钟的 ID 确保分布式系统下的事件顺序
- 操作永远是添加而非删除：通过标记操作的状态来代表删除而非真实删除操作节点

###### Yjs 编辑/同步交互流程

![yjs 交互流程](https://origin.picgo.net/2025/09/13/yjs8bfb5b7c77cf0293.png)

###### Yjs 核心概念

```tsx
import * as Y from "yjs";
const ydoc = new Y.Doc();
const ytext = ydoc.getText("text type");
ytext.insert(0, "abc");
// abc
ytext.toString();
```

`YDoc`：整个协同文档的容器和调度中心，其主要作用如下：

1. 类型注册，getText、getArray 等共享类型的入口
2. 通过 StructStore 存储和管理所有 Item
3. 同步调度，找出并且推送未同步的数据给其他客户端
4. 事务控制，原子操作批处理

`Item`：文档的最小载体

`AbstractContent`：Item 中承载的具体内容，包括 ContentString、ContentJSON、ContentFormat 等结构的

###### StructStore 数据结构

```tsx
export class StructStore {
  constructor() {
    /**
     *@type {Map<number,Array<GC|Item>>}
     */
    this.clients = new Map();
    /**
     *@type {null | { missing: Map<number, number>, update: Uint8Array}}
     */
    this.pendingStructs = null;
    /**
     *@type {null | Uint8Array}
     */
    this.pendingDs = null;
    this.skips = createIdSet();
  }
}
```

###### Item 数据结构

```tsx
export class Item extends AbstractStruct {
  /**
   *@param {ID}id   *@param {Item | null}left   *@param {ID | null}origin   *@param {Item | null}right   *@param {ID | null}rightOrigin   *@param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   *@param {string | null}parentSub   *@param {AbstractContent}content   */
  constructor(
    id,
    left,
    origin,
    right,
    rightOrigin,
    parent,
    parentSub,
    content,
  ) {
    super(id, content.getLength());
    /**
     * The item that was originally to the left of this item.
     *@type {ID | null}
     */
    this.origin = origin;
    /**
     * The item that is currently to the left of this item.
     *@type {Item | null}
     */
    this.left = left;
    /**
     * The item that is currently to the right of this item.
     *@type {Item | null}
     */
    this.right = right;
    /**
     * The item that was originally to the right of this item.
     *@type {ID | null}
     */
    this.rightOrigin = rightOrigin;
    /**
     *@type {AbstractType<any>|ID|null}
     */
    this.parent = parent;
    /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     *@type {String | null}
     */
    this.parentSub = parentSub;
    /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     *@type {ID | null}
     */
    this.redone = null;
    /**
     *@type {AbstractContent}
     */
    this.content = content;
    /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     *@type {number}byte     */
    this.info = this.content.isCountable() ? binary.BIT2 : 0;
  }
}
```

## 3. 总结

本文梳理了在线文档的产品和技术的发展历程：从 WPS、Office 等本地办公软件，到 Google Docs、石墨文档等云端协作平台，再到 Notion、飞书文档等智能协作工具

从技术层面来看，富文本编辑器构建于一系列底层 API 之上，包括 contenteditable、execCommand（已逐渐被废弃）、Range 与 Selection 等，这些接口共同实现对文档内容的可视化编辑。另一方面，现代富文本编辑器通常基于 DSL 设计其存储结构，以实现更高效的内容描述与状态管理

在实时协作方面，主流技术主要包括 OT 算法和 CRDT。OT 通过对操作进行转换和调整来解决并发冲突，而 CRDT 则利用特殊数据结构实现分布式自动同步，以 Grow-only Counter、PN-Counter、Yjs 为例展示了 CRDT 的具体实现
